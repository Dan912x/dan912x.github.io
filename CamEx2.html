<!DOCTYPE html>
<html>
<head>
</head>
<!-- from https://stackoverflow.com/questions/58499997/is-it-possible-to-manipulate-camera-data-before-sending-in-webrtc -->
<body>
  <!--
    <button id="allow-access" style="font-family: Arial, sans-serif; font-size: 30px">1 Start</button>
  -->
  <video id="demo" autoplay></video>
  <canvas id="outputCanvas"></canvas>

  <script>
      var dancount = 1000;
      var start = 0;
      var prevTimeStamp = 0;
      // I shamelessly copied this from https://www.permadi.com/tutorial/jsCanvasGrayscale/index.html
      function grayScaleCanvas(canvas, context){
          console.log(dancount, 'grayScaleCanvas', canvas);
          const width = canvas.width;
          const height = canvas.height;
          const frame=context.getImageData(0,0, width, height);
          // This loop gets every pixel on the image and puts the rgb average as value
          for (let i=0; i<height; i++){
              for (let j=0; j<width; j++){
                  const index=(i*4)*frame.width+(j*4);
                  const red=frame.data[index];
                  const green=frame.data[index+1];
                  const blue=frame.data[index+2];
                  const average=(red+green+blue)/3;
                  frame.data[index]=average;
                  frame.data[index+1]=average;
                  frame.data[index+2]=average;
              }
          }
          context.putImageData(frame, 0, 0);
      }

      // 1. paint the getUserMedia-Stream on a canvas,
      // 2. manipulate the canvas to create the grayscale-effect,
      // 3.return a canvas capture stream with the given framerate
      function streamToGrayScaledVersion(stream, fps=30, width=640, height=480){
          if (start == 0) {
            start = Date.now();  // just once
          }
          console.log(dancount, 'set up streamttoGSV', stream);
          const video = document.createElement('video');
          video.autoplay = true;
          video.srcObject = stream;
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext('2d');
          const toCanvas = function(timeStamp){
              console.log('callback elapsed', timeStamp - prevTimeStamp, '===', timeStamp);
              prevTimeStamp = timeStamp;
              dancount++;
              context.drawImage(video, 0, 0, width, height);  // video -> canvas, with scaling
              grayScaleCanvas(canvas, context);             // manipulate canvas
              context.font = '24px serif';
              context.fillText('12 Dancount ' + dancount + ' fps:' +
                      Math.round((dancount-1000) / ((Date.now() - start) / 1000), 1),
                      100,100);
              //for (let x = 0; x<640; x+=50) {
              //  context.beginPath();
              //  context.strokeStyle = "green";
              //  context.moveTo(x, 0);
              //  context.lineTo(x, 480);
              //  context.stroke();
              //}
              if (dancount<1500) {
                requestAnimationFrame(toCanvas);              // do it again!
              }
          };
          requestAnimationFrame(toCanvas);  // call this before each repaint
          return canvas.captureStream(fps); // sent to second then
      }

      //document.getElementById('allow-access').addEventListener('click', async function init(e) {
      const demoVideo = document.getElementById("demo");
      console.log('demoVideo:\n', demoVideo);
      const constraints = {video: { frameRate: { ideal: 10, max: 15 } } };
      navigator.mediaDevices.getUserMedia(constraints)
          .then(streamToGrayScaledVersion)   // gets passed a MediaStream object
          .then(stream => demoVideo.srcObject = stream)
          .catch(console.error);
  </script>
</body>
</html>
