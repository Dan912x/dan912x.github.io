<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="manifest" href="/manifest.json">
  <!--<link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2" />-->
  <!--<link rel="stylesheet" href="converter.css">-->
  <title>Ghosts</title>
</head>
<!-- from https://stackoverflow.com/questions/58499997/is-it-possible-to-manipulate-camera-data-before-sending-in-webrtc -->
<body style = "background-color: blue;">
  <span style='font-size:20px'>115</span>
  <button type="button" id="ApproveButton"
        onclick="askPermission()" style="height: 300px, width: 400px">Approve</button>
  <p>
  <video id="demo" hidden autoplay style='border-style: dotted'></video>
  <canvas id="outputCanvas"
        style='border-style: double, position: absolute, top: 50px, left: 50px'></canvas>

  <script>
      var dancount = 1000;
      var start = Date.now();
      var prevTimeStamp = 0;
      var setDimensionsCount = 0;
      var setDimensionsInfo = '';

      const demoVideo = document.getElementById('demo');
      // macOS Safari doesn't work right with non-attached video
      //const demoVideo = document.createElement('video');
      //demoVideo.setAttribute('id', 'demo');
      demoVideo.autoplay = true;

      // for iOS Safari   see https://leemartin.dev/hello-webrtc-on-safari-11-e8bcb5335295
      // see also https://webkit.org/blog/6784/new-video-policies-for-ios/
      demoVideo.setAttribute('autoplay', '');
      demoVideo.setAttribute('muted', '');
      demoVideo.setAttribute('playsinline', '')
      console.log('demoVideo:\n', demoVideo);

      var D1 = 400;  // long dimension
      var D2 = D1 * 3/4;  // short dimension, 4:3 ratio
      var canvas = document.getElementById('outputCanvas');
      canvas.width = D2;
      canvas.height = D1;
      const context = canvas.getContext('2d');
      var canvasUpdateToVideoDimensions = false;

      var orAbsolute = 'unset';
      var orX = 101;
      var orY = 102;
      var orZ = 103;
      var orC = 104;
      var orScreenOrientation = screen.orientation.angle;
      var shookCount = 0;

      window.addEventListener("orientationchange",
          (event) => {orScreenOrientation = screen.orientation.angle;
                      if (orScreenOrientation == 0 || orScreenOrientation == 180) {
                        canvas.width = D2;
                        canvas.height = D1;
                      }
                      else {
                        canvas.width = D1;
                        canvas.height = D2;
                      }
                      console.log('**orientation change event:', orScreenOrientation)});

      window.addEventListener("deviceorientation", shook);
      console.log('   added deviceorientation listener 1 shook()');
      setCanvasDimensions();  // on load

      function askPermission() {
        console.log("In askPermission, DeviceOrientationEvent:");
        document.getElementById("ApproveButton").style.color="pink";
        document.getElementById("ApproveButton").innerHTML = typeof DeviceOrientationEvent.requestPermission;
        // Request permission for iOS 13+ devices
        //if ( DeviceMotionEvent &&
        //    typeof DeviceMotionEvent.requestPermission === "function") {
        //      DeviceMotionEvent.requestPermission();
        //      window.addEventListener("deviceorientation", shook);
        //  }
        if ( DeviceOrientationEvent &&
            typeof DeviceOrientationEvent.requestPermission === "function") {
              DeviceOrientationEvent.requestPermission();
              window.addEventListener("deviceorientation", shook);
              console.log('   added deviceorientation listener 2 shook()');
          }
      }

      const constraints = {
        video: {
          frameRate: { ideal: 30, max: 100 },
          facingMode: 'environment',
          width: { min: 480, max: 1920 },  // ideal: 1280
          height: { min: 480, max: 1920 /*1080*/ },  // ideal: 720
        }
      };

      navigator.mediaDevices.getUserMedia(constraints)
          .then(stream =>
              {
                demoVideo.srcObject = stream;
                requestAnimationFrame(updateCanvas);  // call this before each repaint
              })
          .catch(console.error);


      function shook(event) {
        if (shookCount < 10)
          console.log('shook', event.webkitCompassHeading, event);
        orAbsolute = event.absolute;  // not in iOS, evidently
        orX = event.beta;
        orY = event.gamma;
        orZ = event.alpha;
        orC = event.webkitCompassHeading;  // maybe iOS only, not Android
        shookCount++;
      }

      function updateCanvas(timeStamp){
          //console.log('callback elapsed',
          //        Math.round(timeStamp - prevTimeStamp, 1), '===', timeStamp);
          prevTimeStamp = timeStamp;
          dancount++;
          if (!canvasUpdateToVideoDimensions && demoVideo.videoWidth && demoVideo.videoHeight) {
            console.log('updating wxh B', demoVideo.videoWidth, demoVideo.videoHeight);
            setCanvasDimensions();
            canvasUpdateToVideoDimensions = true;
          }
          if (orScreenOrientation != '???') {
            console.log('.... orientation:', orScreenOrientation, '         ',
                          dancount);
            console.log('.... shook:', shookCount);
            console.log('......... window width', window.innerWidth, ' height',
                                  window.innerHeight);
            console.log('......... canvas width', canvas.width, ' height', canvas.height);
            console.log('.........  video width', demoVideo.videoWidth,
                          'height', demoVideo.videoHeight)
          }
          //context.drawImage(demoVideo, 0, 0, canvas.width, canvas.height);  // video -> canvas, with scaling
          context.drawImage(demoVideo, 0, 0, canvas.width, canvas.height,
                            0, 0, canvas.width, canvas.height);  // no scaling
          convertToGrayScale();           // manipulate canvas
          context.font = 'bold 50px serif';
          context.fillText('115', 50, 60);
          context.fillText('x: ' + Math.round(orX) + ' y: ' + Math.round(orY) +
                          ' z: ' + Math.round(orZ) + ' ch:' +
                              Math.round(orC), 50, 120);
          context.fillText('or: ' + orScreenOrientation, 50, 180);
          context.fillText('shookCount: ' + shookCount, 50, 240);
          if (document.visibilityState != 'visible') {
            console.log('***** GOODBYE *****');
            return;
          }
          //if (dancount<2000) {
          requestAnimationFrame(updateCanvas);            // do it again!
      }; // end updateCanvas

      window.onresize = setCanvasDimensions;
      // see https://stackoverflow.com/questions/73493417/ios-chrome-yields-incorrect-window-innerwidth-and-innerheight
      function setCanvasDimensions() {
        console.log('>>>', window.innerWidth, window.innerHeight);
        return;  // make this function a nop for now
        //window.setTimeout(setCanvasDimensionsAfterWait, 25);
      }
      /*
      function setCanvasDimensionsAfterWait() {
        console.log("---setCanvasDimensionsAfterWait()---");
        if (demoVideo.videoWidth && demoVideo.videoHeight) {
          let videoRatio = demoVideo.videoWidth / demoVideo.videoHeight;
          console.log(' sizing', canvas.width, 'x', canvas.height,
                      ' video width/height:', videoRatio,
                      ' window width x height:', window.innerWidth, 'x',
                            window.innerHeight);
          let possibleCanvasHeight = window.innerWidth / videoRatio;
          if (possibleCanvasHeight <= window.innerHeight) {
            canvas.width = window.innerWidth;
            canvas.height = Math.floor(possibleCanvasHeight);
          }
          else {
            canvas.width = Math.floor(window.innerHeight * videoRatio);
            canvas.height = window.innerHeight;
          }
          console.log('    ==>', canvas.width, 'x', canvas.height)
        }
        else {
          console.log('  called setCanvasRatio, nop');
        }
        //setDimensionsCount++;
        //setDimensionsInfo = 'SET ' + setDimensionsCount + ' video: ' +
        //      demoVideo.videoWidth + 'x' + demoVideo.videoHeight + '  canvas:' +
        //      canvas.width + 'x' + canvas.height;
      }
      */

      function convertToGrayScale() {
          //console.log(dancount, 'grayScaleCanvas', canvas);
          const frame=context.getImageData(0, 0, canvas.width, canvas.height);
          // This loop gets every pixel on the image and puts the rgb average as value
          for (let i=0; i<canvas.height; i++){
              for (let j=0; j<canvas.width; j++){
                  let index=(i*4)*frame.width+(j*4);
                  let red=frame.data[index];
                  let green=frame.data[index+1];
                  let blue=frame.data[index+2];
                        //if (i == 200 && j == 200)
                        //  console.log('peek 200x200 <', red, green, blue, '>');
                  let average=(red+green+blue)/3;
                  if (average < 230)
                    average = average + 25;   // lighten up a bit
                  frame.data[index]=average;
                  frame.data[index+1]=average;
                  frame.data[index+2]=average;
              }
          }
          context.putImageData(frame, 0, 0);
      }
  </script>
  <script>
  if('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js', { scope: '/' });
  }
  window.addEventListener("visibilitychange", function () {
    console.log("Visibility changed", document.visibilityState);
    if (document.visibilityState === "visible") {
      console.log("App Ghost resumed");
      window.location.reload();  // reload from server, hopefully
    }
  });
  </script>
</body>
</html>
