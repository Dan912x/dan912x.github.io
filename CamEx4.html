<!DOCTYPE html>
<html>
<head>
</head>
<!-- from https://stackoverflow.com/questions/58499997/is-it-possible-to-manipulate-camera-data-before-sending-in-webrtc -->
<body>
  <!--
  <h1>Run 24</h1>
  <p>
  hello
  <p>
  -->
  <h1 id="dan">Info</h1>
  <button type="button" id="ApproveButton" onclick="askPermission()" style="height: 100px, width: 200px">Approve</button>
  <video id="demo" hidden autoplay style='border-style: dotted'></video>
  <canvas id="outputCanvas" style='border-style: double'></canvas>

  <script>
      let in1 = 'xxx';
      if (DeviceMotionEvent)
        in1 = typeof DeviceMotionEvent.requestPermission;
      else
        in1 = 'DeviceMoEv not defined'
      document.getElementById('dan').innerHTML = in1;

      // Based on CamEx2a, with sensor experiments
      var dancount = 1000;
      var start = Date.now();
      var prevTimeStamp = 0;
      setDimensionsCount = 0;
      setDimensionsInfo = '';

      const demoVideo = document.getElementById('demo');
      // macOS Safari doesn't work right with non-attached video
      //const demoVideo = document.createElement('video');
      //demoVideo.setAttribute('id', 'demo');
      demoVideo.autoplay = true;

      // for iOS Safari   see https://leemartin.dev/hello-webrtc-on-safari-11-e8bcb5335295
      // see also https://webkit.org/blog/6784/new-video-policies-for-ios/
      demoVideo.setAttribute('autoplay', '');
      demoVideo.setAttribute('muted', '');
      demoVideo.setAttribute('playsinline', '')
      console.log('demoVideo:\n', demoVideo);

      const canvas = document.getElementById('outputCanvas');
      canvas.width = 200;  // dummy values
      canvas.height = 200;
      const context = canvas.getContext('2d');
      var canvasUpdateToVideoDimensions = false;

      var orAbsolute;
      var orX = 101;
      var orY = 102;
      var orZ = 103;
      var orScreenOrientation = '???'
      var shookCount = 0;
      //ondeviceorientation = shook;
      window.addEventListener("deviceorientation", shook);
      window.addEventListener("change",
            (event) => {orScreenOrientation = event.target.type})

      function askPermission() {
        document.getElementById("ApproveButton").style.color="pink";
        document.getElementById("ApproveButton").innerHTML = typeof DeviceMotionEvent.requestPermission;
        // Request permission for iOS 13+ devices
        if ( DeviceMotionEvent &&
            typeof DeviceMotionEvent.requestPermission === "function") {
              DeviceMotionEvent.requestPermission();
          }
      }

      const constraints = {
        video: {
          frameRate: { ideal: 60, max: 100 },
          facingMode: 'environment',
          width: { min: 480, ideal: 1280, max: 1920 },
          height: { min: 480, ideal: 720, max: 1080 },
        }
      };

      navigator.mediaDevices.getUserMedia(constraints)
          .then(stream =>
              {
                demoVideo.srcObject = stream;
                requestAnimationFrame(updateCanvas);  // call this before each repaint
              })
          .catch(console.error);


      function shook(event) {
        console.log('shook', event);
        orAbsolute = event.absolute;
        orX = event.beta;
        orY = event.gamma;
        orZ = event.alpha;
        shookCount++;
      }

      function updateCanvas(timeStamp){
          //console.log('callback elapsed',
          //        Math.round(timeStamp - prevTimeStamp, 1), '===', timeStamp);
          prevTimeStamp = timeStamp;
          dancount++;
          if (!canvasUpdateToVideoDimensions && demoVideo.videoWidth && demoVideo.videoHeight) {
            console.log('updating wxh B', demoVideo.videoWidth, demoVideo.videoHeight);
            setCanvasDimensions();
            canvasUpdateToVideoDimensions = true;
          }
          context.drawImage(demoVideo, 0, 0, canvas.width, canvas.height);  // video -> canvas, with scaling
          convertToGrayScale();           // manipulate canvas
          context.font = '60px serif bold';
          context.fillText('15 absolute: ' + orAbsolute, 50, 60);
          context.fillText('x: ' + Math.round(orX) + ' y: ' + Math.round(orY) +
                          ' z: ' + Math.round(orZ), 50, 120);
          //context.fillText('x: ' + Math.round(orX), 50, 120);
          //context.fillText('y: ' + Math.round(orY), 50, 180);
          //context.fillText('z: ' + Math.round(orZ), 50, 240);
          context.fillText('o: ' + orScreenOrientation, 50, 180);
          context.fillText('shookCount: ' + shookCount, 50, 240);
          context.fillText(setDimensionsInfo, 50, 300);
          /*
          context.fillText('5 Dancount ' + dancount + ' fps: ' +
                  Math.round((dancount-1000) / ((Date.now() - start) / 1000), 1),
                  50,50);
          context.fillText('  vw: ' + demoVideo.videoWidth + ' vh: ' + demoVideo.videoHeight,
                  50,130);
          context.fillText('iw: ' + window.innerWidth + ' ih: ' + window.innerHeight, 50, 210);
          context.fillText('cw ' + canvas.width + ' ch ' + canvas.height, 50, 290);
          */
          if (dancount<2500) {
            requestAnimationFrame(updateCanvas);            // do it again!
          }
      }; // end toCanvas

      window.onresize = setCanvasDimensions;
      function setCanvasDimensions() {
        if (demoVideo.videoWidth && demoVideo.videoHeight) {
          let videoRatio = demoVideo.videoWidth / demoVideo.videoHeight;
          console.log(' sizing', canvas.width, 'x', canvas.height,
                      ' factor:', videoRatio);
          let possibleCanvasHeight = window.innerWidth / videoRatio;
          if (possibleCanvasHeight <= window.innerHeight) {
            canvas.width = window.innerWidth;
            canvas.height = Math.floor(possibleCanvasHeight);
          }
          else {
            canvas.width = Math.floor(window.innerHeight * videoRatio);
            canvas.height = window.innerHeight;
          }
          console.log('    ==>', canvas.width, 'x', canvas.height)
        }
        else {
          console.log('  called setCanvasRatio, nop');
        }
        setDimensionsCount++;
        setDimensionsInfo = 'SET ' + setDimensionsCount + ' video: ' +
              demoVideo.videoWidth + 'x' + demoVideo.videoHeight + '  canvas:' +
              canvas.width + 'x' + canvas.height;
      }


      function convertToGrayScale() {
          //console.log(dancount, 'grayScaleCanvas', canvas);
          const frame=context.getImageData(0,0, canvas.width, canvas.height);
          // This loop gets every pixel on the image and puts the rgb average as value
          for (let i=0; i<canvas.height; i++){
              for (let j=0; j<canvas.width; j++){
                  let index=(i*4)*frame.width+(j*4);
                  let red=frame.data[index];
                  let green=frame.data[index+1];
                  let blue=frame.data[index+2];
                        //if (i == 200 && j == 200)
                        //  console.log('peek 200x200 <', red, green, blue, '>');
                  let average=(red+green+blue)/3;
                  frame.data[index]=average;
                  frame.data[index+1]=average;
                  frame.data[index+2]=average;
              }
          }
          context.putImageData(frame, 0, 0);
      }
  </script>
</body>
</html>
