<!DOCTYPE html>
<html>
<head>
</head>
<!-- from https://stackoverflow.com/questions/58499997/is-it-possible-to-manipulate-camera-data-before-sending-in-webrtc -->
<body>
  <!--
    <button id="allow-access" style="font-family: Arial, sans-serif; font-size: 30px">1 Start</button>
  -->
  <video id="demo" autoplay style='border-style: dotted'></video>
  <p>
  hello
  <p>
  <canvas id="outputCanvas" style='border-style: double'></canvas>

  <script>
      var dancount = 1000;
      var start = 0;
      var prevTimeStamp = 0;

      const demoVideo = document.getElementById('demo');
      console.log('12 demoVideo:\n', demoVideo);
      //video.autoplay = true;
      //demoVideo.srcObject = stream;

      const canvas = document.getElementById('outputCanvas');
      canvas.width = 640;
      canvas.height = 480;
      const context = canvas.getContext('2d');

      const constraints = {video: { frameRate: { ideal: 20, max: 100 } } };

      navigator.mediaDevices.getUserMedia(constraints)
          .then(streamToGrayScaledVersion)   // gets passed a MediaStream object
          .then(stream => demoVideo.srcObject = stream)
          .catch(console.error);

      //-------------------------------------------------
      function grayScaleCanvas() { //canvas, context){
          console.log(dancount, 'grayScaleCanvas', canvas);
          const width = canvas.width;
          const height = canvas.height;
          const frame=context.getImageData(0,0, width, height);
          // This loop gets every pixel on the image and puts the rgb average as value
          for (let i=0; i<height; i++){
              for (let j=0; j<width; j++){
                  const index=(i*4)*frame.width+(j*4);
                  const red=frame.data[index];
                  const green=frame.data[index+1];
                  const blue=frame.data[index+2];
                        if (i == 200 && j == 200)
                          console.log('peek 200x200 <', red, green, blue, '>');
                  const average=(red+green+blue)/3;
                  frame.data[index]=average;
                  frame.data[index+1]=average;
                  frame.data[index+2]=average;
              }
          }
          context.putImageData(frame, 0, 0);
      }

      // 1. paint the getUserMedia-Stream on a canvas,
      // 2. manipulate the canvas to create the grayscale-effect,
      // 3.return a canvas capture stream with the given framerate
      function streamToGrayScaledVersion(stream) { //, fps=30, width=640, height=480){
          if (start == 0) {
            start = Date.now();  // just once
          }
          demoVideo.srcObject = stream;

          const toCanvas = function(timeStamp){
              console.log('callback elapsed', timeStamp - prevTimeStamp, '===', timeStamp);
              prevTimeStamp = timeStamp;
              dancount++;
              context.drawImage(demoVideo, 0, 0, 640, 480);  // video -> canvas, with scaling
              grayScaleCanvas(); //(canvas, context);             // manipulate canvas
              context.font = '24px serif';
              context.fillText('Dancount ' + dancount + ' fps:' +
                      Math.round((dancount-1000) / ((Date.now() - start) / 1000), 1),
                      100,100);
              //for (let x = 0; x<640; x+=50) {
              //  context.beginPath();
              //  context.strokeStyle = "green";
              //  context.moveTo(x, 0);
              //  context.lineTo(x, 480);
              //  context.stroke();
              //}
              if (dancount<1300) {
                requestAnimationFrame(toCanvas);              // do it again!
              }
          }; // end toCanvas
          requestAnimationFrame(toCanvas);  // call this before each repaint
          return canvas.captureStream();  // (fps); // sent to second then
      } // end streamToGSV
  </script>
</body>
</html>
