<!DOCTYPE html>
<html>
<head>
</head>
<!-- from https://stackoverflow.com/questions/58499997/is-it-possible-to-manipulate-camera-data-before-sending-in-webrtc -->
<body>
  <h1>Run 21</h1>
  <video id="demo" hidden autoplay style='border-style: dotted'></video>
  <p>
  hello
  <p>
  <canvas id="outputCanvas" style='border-style: double'></canvas>

  <script>
      var dancount = 1000;
      var start = Date.now();
      var prevTimeStamp = 0;

      const demoVideo = document.getElementById('demo');
      // macOS Safari doesn't work right with non-attached video
      //const demoVideo = document.createElement('video');
      //demoVideo.setAttribute('id', 'demo');
      demoVideo.autoplay = true;

      // for iOS Safari   see https://leemartin.dev/hello-webrtc-on-safari-11-e8bcb5335295
      // see also https://webkit.org/blog/6784/new-video-policies-for-ios/
      demoVideo.setAttribute('autoplay', '');
      demoVideo.setAttribute('muted', '');
      demoVideo.setAttribute('playsinline', '')
      console.log('demoVideo:\n', demoVideo);

      const canvas = document.getElementById('outputCanvas');
      canvas.width = 640;  // 640
      canvas.height = 840;  // 480
      const context = canvas.getContext('2d');

      const constraints = {video: { frameRate: { ideal: 20, max: 100 }, facingMode: 'user' } };

      navigator.mediaDevices.getUserMedia(constraints)
          .then(stream =>
              {
                demoVideo.srcObject = stream;
                requestAnimationFrame(updateCanvas);  // call this before each repaint
              })
          .catch(console.error);

      function updateCanvas(timeStamp){
          console.log('callback elapsed',
                  Math.round(timeStamp - prevTimeStamp, 1), '===', timeStamp);
          prevTimeStamp = timeStamp;
          dancount++;
          context.drawImage(demoVideo, 0, 0, canvas.width, canvas.height);  // video -> canvas, with scaling
          convertToGrayScale();           // manipulate canvas
          context.font = '24px serif';
          context.fillText('Dancount ' + dancount + ' fps: ' +
                  Math.round((dancount-1000) / ((Date.now() - start) / 1000), 1) +
                  '  vw: ' + demoVideo.videoWidth + ' vh: ' + demoVideo.videoHeight +
                  ' iw: ' + window.innerWidth + ' ih: ' + window.innerHeight,
                  50,50);
          //for (let x = 0; x<640; x+=50) {
          //  context.beginPath();
          //  context.strokeStyle = "green";
          //  context.moveTo(x, 0);
          //  context.lineTo(x, 480);
          //  context.stroke();
          //}
          if (dancount<1200) {
            requestAnimationFrame(updateCanvas);            // do it again!
          }
      }; // end toCanvas

      function convertToGrayScale() {
          //console.log(dancount, 'grayScaleCanvas', canvas);
          const frame=context.getImageData(0,0, canvas.width, canvas.height);
          // This loop gets every pixel on the image and puts the rgb average as value
          for (let i=0; i<canvas.height; i++){
              for (let j=0; j<canvas.width; j++){
                  let index=(i*4)*frame.width+(j*4);
                  let red=frame.data[index];
                  let green=frame.data[index+1];
                  let blue=frame.data[index+2];
                        //if (i == 200 && j == 200)
                        //  console.log('peek 200x200 <', red, green, blue, '>');
                  let average=(red+green+blue)/3;
                  frame.data[index]=average;
                  frame.data[index+1]=average;
                  frame.data[index+2]=average;
              }
          }
          context.putImageData(frame, 0, 0);
      }
  </script>
</body>
</html>
